--###################################################################
--08Feb22 Assignment
--###################################################################
--ORACLE INDEX
        --A. Create Index
        --B. Unique Index
        --C. Function-Based Index
        --D. Bitmap Index
--Oracle FETCH
--Oracle Aggregate Functions
--Oracle Analytic Functions
--###################################################################

--###################################################################
--A. Create Table of Members
--###################################################################
CREATE TABLE members(
    member_id INT GENERATED BY DEFAULT AS IDENTITY,
    first_name VARCHAR2(100) NOT NULL,
    last_name VARCHAR2(100) NOT NULL,
    gender CHAR(1) NOT NULL,
    dob DATE NOT NULL,
    email VARCHAR2(255) NOT NULL,
    PRIMARY KEY(member_id)
);

SELECT COUNT(member_id) FROM members;
--###################################################################
--To view all indexes of a table, you query from the all_indexes view:
--###################################################################
SELECT 
    index_name, 
    index_type, 
    visibility, 
    status 
FROM 
    all_indexes
WHERE 
    table_name = 'MEMBERS';
    
--###################################################################
--Creating an index on one column example
--###################################################################
CREATE INDEX  i_members_last_name 
ON members(last_name);

SELECT 
    index_name, 
    index_type, 
    visibility, 
    status 
FROM 
    all_indexes
WHERE 
    table_name = 'MEMBERS';
    
--###################################################################
--finds members whose last name is Harse:
--To check if a query uses the index for lookup or not, you follow these steps:
--First, add the EXPLAIN PLAN FOR clause immediately before the SQL statement:
--Then, use the DBMS_XPLAN.DISPLAY() procedure to show the content of the plan_table:
--###################################################################    
SELECT * FROM members
WHERE last_name = 'Harse';

EXPLAIN PLAN FOR
SELECT * FROM members
WHERE last_name = 'Harse';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());
    
--###################################################################
--Drop or Remove Index:
--###################################################################    
DROP INDEX   i_members_last_name;

--###################################################################
--Creating an index on multiple columns example:
--################################################################### 
CREATE INDEX members_name_i
ON members(last_name,first_name);

SELECT * 
FROM members
WHERE last_name LIKE 'A%' 
    AND first_name LIKE 'M%';
    
EXPLAIN PLAN FOR
SELECT * 
FROM members
WHERE last_name LIKE 'A%' 
    AND first_name LIKE 'M%';
   
SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());

--##################################################################
--B. Oracle UNIQUE index
--##################################################################

--##################################################################
--use Oracle unique index to prevent duplicate values in the indexed column or columns of a table.
--An index can be unique or non-unique. 
--A unique index ensures that no two rows of a table have duplicate values in the indexed column (or columns). 
--A non-unique index does not impose this restriction on the indexed column’s values.
--##################################################################

--##################################################################
--To create a unique index, you use the CREATE UNIQUE INDEX statement:
--##################################################################
CREATE UNIQUE INDEX  i_members_email
ON members(email);

--##################################################################
--The following statement will fail because it attempts to insert a new row whose email already exists:
--##################################################################
INSERT INTO members(first_name, last_name, gender, dob, email)
VALUES('Pegpa','Elce','F',DATE '1990-01-02','pelce0@trellian.com');

--ERROR :- unique constraint (C##MYWORK.SYS_C008346) violated

--##################################################################
--Oracle UNIQUE index on two columns :
--##################################################################

--##################################################################
--creates a new table named demo with two columns a and b:
--##################################################################
CREATE TABLE demo(
    a INT,
    b INT
); 

--##################################################################
--To create a unique index on the two columns a and b  :
--##################################################################
CREATE UNIQUE INDEX i_demo_ab
ON demo(a,b);

--##################################################################
--Insert new rows in demo table :
--##################################################################
INSERT INTO demo(a,b)
VALUES(1,1);

INSERT INTO demo(a,b)
VALUES(1,2);

--##################################################################
--But when we insert same value to Unique index it shows error :
--##################################################################
INSERT INTO demo(a,b)
VALUES(1,1);

--ERROR :- unique constraint (C##MYWORK.I_DEMO_AB) violated

--##################################################################
--Oracle UNIQUE index, Primary Key constraint, and Unique constraint :-
    --When you define a PRIMARY KEY or a UNIQUE constraint for a table, 
    --Oracle automatically creates a unique index on the primary key or unique key columns to enforce the uniqueness.
    --The unique index associated with the constraint always has the name of the constraint, unless specify it explicitly otherwise.
--##################################################################

CREATE TABLE t1 (
    pk1 INT PRIMARY KEY,
    c1 INT
);

--##################################################################
--To show the indexes of the t1 table, you use the following statement :
--##################################################################
SELECT 
    index_name, 
    index_type, 
    visibility, 
    status 
FROM 
    all_indexes
WHERE 
    table_name = 'T1';
    
--##################################################################
--To specify the name for the primary key column, you use the UNIQUE index as shown in the following query :
--##################################################################
CREATE TABLE t2 (
    pk2 INT PRIMARY KEY 
        USING INDEX (
            CREATE INDEX t1_pk1_i ON t2 (pk2)
    ),
    c2 INT
);

SELECT 
    index_name, 
    index_type, 
    visibility, 
    status 
FROM 
    all_indexes
WHERE 
    table_name = 'T2';

--Instead of generating the index name, Oracle just used the one that we provided during table creation.
--##################################################################

--#####################################################################################
--C. Oracle Function-based Index
    ----Use the Oracle function-based index to speed up queries that consist of functions.
--#####################################################################################
--Creates an index on the last_name column of the members table:
--#####################################################################################
CREATE INDEX members_last_name_i 
ON members(last_name);

--If you use the last name column in the WHERE clause, the query optimizer will definitely use the index:

SELECT * FROM members
WHERE last_name = 'Sans';

--#####################################################################################
--However, if you use a function on the indexed column last_name as follows:
--#####################################################################################
SELECT * FROM members
WHERE UPPER(last_name) = 'SANS';

--the query optimizer could not leverage the index.
--The following statements show the execution plan of the query above:

EXPLAIN PLAN FOR
SELECT * FROM members
WHERE UPPER(last_name) = 'SANS';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());
--#####################################################################################
--To encounter this, Oracle introduced function-based indexes.
--A function-based index calculates the result of a function that involves one or more columns and stores that result in the index.
--#####################################################################################

--#####################################################################################
--Creating a function-based index:
    --CREATE INDEX index_name
    --ON table_name (expression)
    
    --In this syntax, the index expression can be an arithmetic expression or an expression that contains
    --a function such as a SQL function, PL/SQL function, and package function.

    --Note that a function-based index can be a btree or bitmap index.
--#####################################################################################

--#####################################################################################
--Creates a function-based index based on the UPPER function:
    --In this example, Oracle converted all values in the last_name column to uppercase and 
    --stored these results in the fi_members_last_name index.
--#####################################################################################
CREATE INDEX  fi_members_last_name
ON members(UPPER(last_name));

--#####################################################################################
--Now, if you find members by the last name, the query optimizer will consider the index as shown in the following query plan:
--#####################################################################################
EXPLAIN PLAN FOR
SELECT * FROM members
WHERE UPPER(last_name) = 'SANS';

SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());

--###################################################################
--A. Bitmap Index
--###################################################################
SELECT 
    *
FROM
    members
WHERE
    gender = 'F';
    
--###################################################################
--The gender column has two distinct values, F for female and M for male. 
--When a column has a few distinct values, we say that this column has low cardinality.
--Oracle has a special kind of index for these types of columns which is called a bitmap index.

--Creating Bitmap Index.
--###################################################################
CREATE BITMAP INDEX bi_members_gender
ON members(gender);

EXPLAIN PLAN FOR 
SELECT 
    *
FROM
    members
WHERE
    gender = 'F';

    
SELECT 
    PLAN_TABLE_OUTPUT 
FROM 
    TABLE(DBMS_XPLAN.DISPLAY());   
    
--###########################################################

CREATE TABLE bitmap_index_demo(
    id INT GENERATED BY DEFAULT AS IDENTITY,
    active NUMBER NOT NULL,
    PRIMARY KEY(id)
);

CREATE BITMAP INDEX bitmap_index_demo_active_i
ON bitmap_index_demo(active);
    
INSERT INTO bitmap_index_demo(active) 
VALUES(1);

INSERT INTO bitmap_index_demo(active) 
VALUES(0);

--######################################################################
   --Oracle FETCH
--###################################################################### 
SELECT
  deptno,ename, dname,sal
FROM
   emp
INNER JOIN dept
        USING(deptno)
ORDER BY
    deptno 
FETCH NEXT 5 ROWS  ONLY;

SELECT
  deptno,ename, dname,sal
FROM
   emp
INNER JOIN dept
        USING(deptno)
ORDER BY
    deptno 
FETCH NEXT 5 ROWS  WITH TIES;

SELECT
  deptno,ename, dname,sal
FROM
   emp
INNER JOIN dept
        USING(deptno)
ORDER BY
    deptno 
FETCH FIRST 40 PERCENT ROWS ONLY;

SELECT
  deptno,ename, dname,sal
FROM
   emp
INNER JOIN dept
        USING(deptno)
ORDER BY
    deptno 
OFFSET 5 ROWS 
FETCH NEXT 10 ROWS ONLY;


--######################################################################
   --Oracle Aggregate Functions
--###################################################################### 
SELECT AVG(Sal), AVG(DISTINCT Sal) 
FROM 
    emp;
    
SELECT SUM (Sal), SUM (DISTINCT Sal) 
FROM 
    emp;

SELECT MAX(Sal), MAX(DISTINCT Sal) 
FROM 
    Emp;
    
SELECT MIN (Sal), MIN (DISTINCT Sal) 
FROM 
    Emp;
    
SELECT STDDEV(Sal), STDDEV(DISTINCT Sal)
FROM 
    Emp;

SELECT VARIANCE(Sal), VARIANCE(DISTINCT Sal)
FROM 
    Emp;

SELECT COUNT(*) 
FROM
Emp;

SELECT Deptno, MAX (Sal) 
FROM 
    Emp
GROUP BY 
    Deptno;

--#############################################################################
--Oracle Analytic Functions
--#############################################################################
SELECT
deptno,sal,
DENSE_RANK () OVER (
ORDER BY deptno)
dept_rank
FROM
emp;

SELECT 
    empno ,job,deptno,
FIRST_VALUE(job)
OVER(PARTITION BY deptno
ORDER BY deptno
)FIRST_JOB
from emp;

SELECT 
    empno ,job,deptno,
LAST_VALUE (job)
OVER(PARTITION BY deptno
ORDER BY deptno
)LAST_JOB
from emp;

--###################################################################### 



